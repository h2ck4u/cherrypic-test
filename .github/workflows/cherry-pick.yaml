name: Auto Cherry-pick

on:
  pull_request:
    types: [closed]

jobs:
  cherry-pick:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Check for cherry-pick labels and execute
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          COMMIT_SHA: ${{ github.event.pull_request.merge_commit_sha }}
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          # PR 라벨 가져오기
          LABELS=$(gh pr view $PR_NUMBER --json labels --jq '.labels[].name' | tr '\n' ' ')
          echo "PR Labels: $LABELS"

          # cherry-pick 대상 브랜치 결정
          TARGET_BRANCH=""
          SOURCE_BRANCH="${{ github.event.pull_request.base.ref }}"

          if echo "$LABELS" | grep -q "cherry-pick-qa"; then
            if [ "$SOURCE_BRANCH" = "main" ]; then
              TARGET_BRANCH="qa"
            else
              echo "cherry-pick-qa 라벨은 main 브랜치로의 PR에서만 사용할 수 있습니다."
              exit 1
            fi
          elif echo "$LABELS" | grep -q "cherry-pick-main"; then
            if [ "$SOURCE_BRANCH" = "qa" ]; then
              TARGET_BRANCH="main"
            else
              echo "cherry-pick-main 라벨은 qa 브랜치로의 PR에서만 사용할 수 있습니다."
              exit 1
            fi
          else
            echo "cherry-pick 라벨이 없습니다. 작업을 건너뜁니다."
            exit 0
          fi

          echo "Source: $SOURCE_BRANCH -> Target: $TARGET_BRANCH"
          echo "Commit SHA: $COMMIT_SHA"

          # PR 정보 가져오기 (merge 방식 포함)
          PR_INFO=$(gh pr view $PR_NUMBER --json commits,mergeCommit,baseRefName,headRefName)

          # Cherry-pick할 커밋 결정
          COMMITS_TO_PICK=""

          # 가장 확실한 방법: merge commit의 부모 수로 판단
          PARENT_COUNT=$(git rev-list --parents -n 1 $COMMIT_SHA | wc -w)
          PARENT_COUNT=$((PARENT_COUNT - 1))  # 첫 번째는 커밋 자체이므로 제외

          echo "Merge commit 부모 수: $PARENT_COUNT"

          if [ "$PARENT_COUNT" -eq 1 ]; then
            # 부모가 1개 = Squash merge 또는 Fast-forward merge
            echo "Squash merge 또는 Fast-forward merge 감지됨. Merge commit을 사용합니다."
            COMMITS_TO_PICK="$COMMIT_SHA"
          else
            # 부모가 2개 이상 = 일반 merge
            echo "일반 merge 감지됨. 개별 커밋들 존재 여부를 확인합니다."
            
            # 개별 커밋들의 존재 여부 확인
            VALID_COMMITS=""
            INVALID_COMMITS=""
            
            for commit in $(echo "$PR_INFO" | jq -r '.commits[] | .oid'); do
              if git cat-file -e $commit 2>/dev/null; then
                VALID_COMMITS="$VALID_COMMITS $commit"
                echo "유효한 커밋: $commit"
              else
                INVALID_COMMITS="$INVALID_COMMITS $commit"
                echo "존재하지 않는 커밋: $commit"
              fi
            done
            
            if [ -n "$VALID_COMMITS" ]; then
              # 유효한 커밋들을 역순으로 정렬 (최신 커밋부터)
              COMMITS_TO_PICK=$(echo $VALID_COMMITS | tr ' ' '\n' | tac | tr '\n' ' ')
              echo "개별 커밋들을 사용합니다: $COMMITS_TO_PICK"
            else
              echo "개별 커밋들이 모두 존재하지 않습니다. Merge commit을 사용합니다."
              COMMITS_TO_PICK="$COMMIT_SHA"
            fi
          fi

          echo "Cherry-pick할 커밋들: $COMMITS_TO_PICK"

          # Cherry-pick 브랜치 이름 생성
          CHERRY_PICK_BRANCH="cherry-pick-${PR_NUMBER}-to-${TARGET_BRANCH}"

          # 대상 브랜치 기반으로 새 브랜치 생성
          git fetch origin $TARGET_BRANCH
          git checkout -b $CHERRY_PICK_BRANCH origin/$TARGET_BRANCH

          # Cherry-pick 실행
          CONFLICT_OCCURRED=false
          CONFLICT_FILES=""

          for commit in $COMMITS_TO_PICK; do
            echo "Cherry-picking commit: $commit"
            if ! git cherry-pick $commit; then
              echo "충돌 발생: $commit"
              CONFLICT_OCCURRED=true
              CONFLICT_FILES=$(git status --porcelain | grep "^UU\|^AA\|^DD" | awk '{print $2}' | tr '\n' ' ')
              
              # 충돌이 있어도 강제로 계속 진행
              echo "충돌을 임시로 표시하고 계속 진행합니다..."
              git status --porcelain | grep "^UU\|^AA\|^DD" | while read -r line; do
                file=$(echo "$line" | awk '{print $2}')
                echo "=== CONFLICT IN $file ===" >> "$file"
                echo "<<<<<<< HEAD (current $TARGET_BRANCH)" >> "$file"
                git show HEAD:"$file" 2>/dev/null || echo "파일이 HEAD에 존재하지 않음" >> "$file"
                echo "=======" >> "$file"
                git show $commit:"$file" 2>/dev/null || echo "파일이 $commit에 존재하지 않음" >> "$file"
                echo ">>>>>>> $commit" >> "$file"
              done
              
              # 충돌 파일들을 staged 상태로 만들기
              git add .
              git cherry-pick --continue
            fi
          done

          # 브랜치 푸시 (충돌이 있어도 강제로 푸시)
          git push origin $CHERRY_PICK_BRANCH

          # PR 생성
          if [ "$CONFLICT_OCCURRED" = true ]; then
            # 충돌이 있는 경우의 PR 생성
            gh pr create \
              --title "🍒⚠️ Cherry-pick (충돌 해결 필요): $PR_TITLE" \
              --body "⚠️ **이 PR은 충돌이 발생한 cherry-pick입니다. 수동 해결이 필요합니다.**
              
              **원본 PR:** #${PR_NUMBER}
              **대상 브랜치:** \`$TARGET_BRANCH\`
              **충돌 파일:** \`$CONFLICT_FILES\`
              
              ## 충돌 해결 방법:
              1. 이 브랜치를 로컬로 체크아웃
              2. 충돌 마커를 찾아 수동으로 해결
              3. 변경사항을 커밋하고 푸시
              
              \`\`\`bash
              git checkout $CHERRY_PICK_BRANCH
              git pull origin $CHERRY_PICK_BRANCH
              # 충돌 파일들을 수동으로 편집
              git add .
              git commit -m \"Resolve cherry-pick conflicts\"
              git push origin $CHERRY_PICK_BRANCH
              \`\`\`
              
              **Cherry-pick된 커밋들:**
              $(for commit in $COMMITS_TO_PICK; do echo "- \`$commit\`"; done)" \
              --base $TARGET_BRANCH \
              --head $CHERRY_PICK_BRANCH \
              --label "cherry-pick,needs-conflict-resolution"
            
            # 원본 PR에 충돌 알림 코멘트
            gh pr comment $PR_NUMBER --body "⚠️ **자동 Cherry-pick - 충돌 해결 필요**
            
            \`$TARGET_BRANCH\` 브랜치로 cherry-pick하는 중 충돌이 발생했습니다.
            충돌이 포함된 PR이 생성되었으니 수동으로 해결해주세요.
            
            **충돌 파일:** \`$CONFLICT_FILES\`
            
            PR 링크: https://github.com/${{ github.repository }}/pulls?q=is%3Apr+head%3A$CHERRY_PICK_BRANCH"
            
          else
            # 충돌이 없는 경우의 정상 PR 생성
            gh pr create \
              --title "🍒 Cherry-pick: $PR_TITLE" \
              --body "이 PR은 #${PR_NUMBER}의 변경사항을 \`$TARGET_BRANCH\` 브랜치로 자동 cherry-pick한 것입니다.
              
              **원본 PR:** #${PR_NUMBER}
              **대상 브랜치:** \`$TARGET_BRANCH\`
              
              **Cherry-pick된 커밋들:**
              $(for commit in $COMMITS_TO_PICK; do echo "- \`$commit\`"; done)
              
              충돌 없이 성공적으로 cherry-pick되었습니다. 변경사항을 검토한 후 병합해주세요." \
              --base $TARGET_BRANCH \
              --head $CHERRY_PICK_BRANCH \
              --label "cherry-pick"
            
            # 원본 PR에 성공 코멘트
            gh pr comment $PR_NUMBER --body "✅ **자동 Cherry-pick 성공**
            
            \`$TARGET_BRANCH\` 브랜치로 cherry-pick하는 PR이 성공적으로 생성되었습니다.
            
            PR 링크: https://github.com/${{ github.repository }}/pulls?q=is%3Apr+head%3A$CHERRY_PICK_BRANCH"
          fi
